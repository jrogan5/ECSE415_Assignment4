# ========================================
# ALTERNATIVE: Faster RCNN (If RetinaNet Fails)
# ========================================
# Use this if the aggressive RetinaNet training still doesn't work

from torchvision.models.detection import fasterrcnn_resnet50_fpn, FasterRCNN_ResNet50_FPN_Weights
from torchvision.models.detection.faster_rcnn import FastRCNNPredictor
import torch
import torch.nn as nn
import numpy as np

print("=" * 70)
print("FASTER RCNN TRAINING")
print("=" * 70)
print("Faster RCNN is a two-stage detector that often works better for:")
print("  - Small objects (like traffic signs)")
print("  - Precise localization")
print("  - Datasets with class imbalance")
print("=" * 70)

# Initialize Faster RCNN with COCO pretrained weights
weights_frcnn = FasterRCNN_ResNet50_FPN_Weights.DEFAULT
model_frcnn = fasterrcnn_resnet50_fpn(weights=weights_frcnn)

# Replace the box predictor head
in_features = model_frcnn.roi_heads.box_predictor.cls_score.in_features
model_frcnn.roi_heads.box_predictor = FastRCNNPredictor(in_features, num_classes + 1)

model_frcnn.to(device)

# SGD optimizer (often works better for Faster RCNN than AdamW)
optimizer_frcnn = torch.optim.SGD(
    model_frcnn.parameters(),
    lr=5e-3,  # Higher LR works well with SGD + momentum
    momentum=0.9,
    weight_decay=5e-4
)

num_epochs_frcnn = 40

# StepLR with earlier decay
lr_scheduler_frcnn = torch.optim.lr_scheduler.StepLR(
    optimizer_frcnn,
    step_size=15,  # Decay every 15 epochs
    gamma=0.1
)

train_losses_frcnn = []
val_losses_frcnn = []

print(f"Initial LR: {optimizer_frcnn.param_groups[0]['lr']:.2e}")
print(f"Optimizer: SGD with momentum=0.9")
print(f"Training for {num_epochs_frcnn} epochs")
print("\nExpected behavior for Faster RCNN:")
print("  Epochs 1-5:   Loss ~3-6 (higher than RetinaNet initially)")
print("  Epochs 5-15:  Loss drops to ~1-2")
print("  Epochs 15-30: Loss drops to ~0.5-1.0")
print("  Epochs 30+:   Loss stabilizes around 0.3-0.7")
print("=" * 70)

for epoch in range(num_epochs_frcnn):
    # Train
    model_frcnn.train()
    running_train_loss = 0.0

    for images, targets in train_loader_v2:
        images = [img.to(device) for img in images]
        targets = [{k: v.to(device) for k, v in t.items()} for t in targets]

        loss_dict = model_frcnn(images, targets)
        losses = sum(loss_dict.values())

        optimizer_frcnn.zero_grad()
        losses.backward()
        optimizer_frcnn.step()

        running_train_loss += losses.item()

    avg_train_loss = running_train_loss / max(1, len(train_loader_v2))
    train_losses_frcnn.append(avg_train_loss)

    # Validation
    running_val_loss = 0.0
    with torch.no_grad():
        model_frcnn.train()
        for images, targets in val_loader_v2:
            images = [img.to(device) for img in images]
            targets = [{k: v.to(device) for k, v in t.items()} for t in targets]

            loss_dict = model_frcnn(images, targets)
            losses = sum(loss_dict.values())
            running_val_loss += losses.item()

    avg_val_loss = running_val_loss / max(1, len(val_loader_v2))
    val_losses_frcnn.append(avg_val_loss)

    lr_scheduler_frcnn.step()
    current_lr = optimizer_frcnn.param_groups[0]['lr']

    # Print more frequently early on
    if epoch < 15 or (epoch + 1) % 5 == 0:
        print(f"Epoch [{epoch+1}/{num_epochs_frcnn}]  "
              f"Train: {avg_train_loss:.4f}  "
              f"Val: {avg_val_loss:.4f}  "
              f"LR: {current_lr:.6f}")

        # Early warnings
        if epoch == 14 and avg_val_loss > 3:
            print("   ⚠️  WARNING: Loss not decreasing as expected")
        elif epoch == 14 and avg_val_loss < 1.5:
            print("   ✓ Training looks healthy!")

print("\n" + "=" * 70)
print("FASTER RCNN TRAINING COMPLETE")
print("=" * 70)
print(f"Final train loss: {train_losses_frcnn[-1]:.4f}")
print(f"Final val loss:   {val_losses_frcnn[-1]:.4f}")
print(f"Best val loss:    {min(val_losses_frcnn):.4f} at epoch {np.argmin(val_losses_frcnn) + 1}")

# Plot losses
import matplotlib.pyplot as plt

plt.figure(figsize=(14, 5))

plt.subplot(1, 2, 1)
plt.plot(train_losses_frcnn, label='Train Loss (Faster RCNN)', linewidth=2)
plt.plot(val_losses_frcnn, label='Val Loss (Faster RCNN)', linewidth=2)
plt.xlabel('Epoch')
plt.ylabel('Loss')
plt.title('Faster RCNN Training Progress')
plt.legend()
plt.grid(True, alpha=0.3)

plt.subplot(1, 2, 2)
plt.plot(train_losses_frcnn, label='Train Loss (Faster RCNN)', linewidth=2)
plt.plot(val_losses_frcnn, label='Val Loss (Faster RCNN)', linewidth=2)
plt.xlabel('Epoch')
plt.ylabel('Loss (log scale)')
plt.yscale('log')
plt.title('Faster RCNN Progress (Log Scale)')
plt.legend()
plt.grid(True, alpha=0.3)

plt.tight_layout()
plt.show()

# Save the model
torch.save(model_frcnn.state_dict(), 'model_faster_rcnn.pth')
print("\nModel saved as 'model_faster_rcnn.pth'")

# Generate submission with Faster RCNN
# Note: You'll need to adapt the submission generation code for Faster RCNN
# (The interface is the same, but box format might differ slightly)

print("\n" + "=" * 70)
print("NEXT STEPS FOR FASTER RCNN")
print("=" * 70)
print("1. Adapt the submission generation code to use model_frcnn")
print("2. Use the same NMS and preprocessing as RetinaNet")
print("3. Try score thresholds: 0.3, 0.4, 0.5")
print("   (Faster RCNN scores are calibrated differently)")
